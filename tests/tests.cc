#include <array>
#include <filesystem>
#include <format>
#include <fstream>
#include <iostream>
#include <set>
#include <vector>

import cd.cd;
import cd.edc;
import cd.scrambler;
import cd.subcode_rw;
import crc.crc;
import crc.crc16_gsm;
import crc.crc32;
import utils.file_io;
import utils.misc;
import utils.strings;



using namespace gpsxre;



bool test_scale()
{
    bool success = true;

    std::vector<std::pair<std::pair<int32_t, uint32_t>, int32_t>> cases = {
        { { 0, 16 },   0  },
        { { 1, 16 },   1  },
        { { 15, 16 },  1  },
        { { 16, 16 },  1  },
        { { 17, 16 },  2  },
        { { 20, 16 },  2  },
        { { 32, 16 },  2  },
        { { 33, 16 },  3  },

        { { -1, 16 },  -1 },
        { { -15, 16 }, -1 },
        { { -16, 16 }, -1 },
        { { -17, 16 }, -2 },
        { { -20, 16 }, -2 },
        { { -32, 16 }, -2 },
        { { -33, 16 }, -3 }
    };

    for(size_t i = 0; i < cases.size(); ++i)
    {
        std::cout << std::format("scale_up({}, {}) -> {}... ", cases[i].first.first, cases[i].first.second, cases[i].second) << std::flush;
        auto s = scale_up(cases[i].first.first, cases[i].first.second);
        if(s == cases[i].second)
            std::cout << "success";
        else
        {
            std::cout << std::format("failure, result: {}", s);
            success = false;
        }

        std::cout << std::endl;
    }

    return success;
}


bool test_lbamsf()
{
    bool success = true;

    std::vector<std::pair<MSF, int32_t>> cases = {
        { { 0, 0, 0 },     -150   },
        { { 0, 0, 1 },     -149   },
        { { 0, 0, 73 },    -77    },
        { { 0, 0, 74 },    -76    },
        { { 0, 1, 0 },     -75    },
        { { 0, 2, 0 },     0      },
        { { 79, 59, 74 },  359849 },
        { { 80, 0, 0 },    359850 },
        { { 89, 59, 74 },  404849 },
        { { 90, 0, 0 },    404850 },
        { { 90, 0, 1 },    404851 },
        { { 90, 1, 0 },    404925 },
        { { 99, 59, 74 },  449849 },
        { { 100, 0, 0 },   449850 },
        { { 160, 0, 0 },   -45150 },
        { { 160, 0, 1 },   -45149 },
        { { 160, 1, 0 },   -45075 },
        { { 169, 59, 74 }, -151   },
        // LEGACY:
        //        {{90,  0,  0}, -45150},
        //        {{90,  0,  1}, -45149},
        //        {{90,  1,  0}, -45075},
        //        {{99, 59, 74},   -151}
    };

    for(size_t i = 0; i < cases.size(); ++i)
    {
        std::cout << std::format("MSF_to_LBA: {:02}:{:02}:{:02} -> {:6}... ", cases[i].first.m, cases[i].first.s, cases[i].first.f, cases[i].second) << std::flush;
        auto lba = MSF_to_LBA(cases[i].first);
        if(lba == cases[i].second)
            std::cout << "success";
        else
        {
            std::cout << std::format("failure, lba: {:6}", lba);
            success = false;
        }

        std::cout << std::endl;
    }

    for(size_t i = 0; i < cases.size(); ++i)
    {
        std::cout << std::format("LBA_to_MSF: {:6} -> {:02}:{:02}:{:02}... ", cases[i].second, cases[i].first.m, cases[i].first.s, cases[i].first.f) << std::flush;
        auto msf = LBA_to_MSF(cases[i].second);
        if(msf.m == cases[i].first.m && msf.s == cases[i].first.s && msf.f == cases[i].first.f)
            std::cout << "success";
        else
        {
            std::cout << std::format("failure, msf: {:02}:{:02}:{:02}", msf.m, msf.s, msf.f);
            success = false;
        }

        std::cout << std::endl;
    }

    return success;
}


bool test_bcd()
{
    bool success = true;

    std::vector<std::pair<uint8_t, uint8_t>> cases = {
        { 0x00, 0   },
        { 0x01, 1   },
        { 0x09, 9   },
        { 0x10, 10  },
        { 0x11, 11  },
        { 0x15, 15  },
        { 0x19, 19  },
        { 0x55, 55  },
        { 0x99, 99  },
        { 0xA0, 100 },
        { 0xA1, 101 },
        { 0xA6, 106 },
        { 0xA9, 109 },
        { 0xB0, 110 },
        { 0xF0, 150 },
        { 0xF9, 159 }
    };

    for(size_t i = 0; i < cases.size(); ++i)
    {
        std::cout << std::format("bcd_decode: {:02X} -> {:3}... ", cases[i].first, cases[i].second) << std::flush;
        auto value = bcd_decode(cases[i].first);
        if(value == cases[i].second)
            std::cout << "success";
        else
        {
            std::cout << std::format("failure, value: {:3}", value);
            success = false;
        }

        std::cout << std::endl;
    }

    for(size_t i = 0; i < cases.size(); ++i)
    {
        std::cout << std::format("bcd_encode: {:3} -> {:02X}... ", cases[i].second, cases[i].first) << std::flush;
        auto value = bcd_encode(cases[i].second);
        if(value == cases[i].first)
            std::cout << "success";
        else
        {
            std::cout << std::format("failure, value: {:02X}", value);
            success = false;
        }

        std::cout << std::endl;
    }

    return success;
}


bool test_unscramble()
{
    bool success = true;

    Scrambler scrambler;

    // DEBUG
    if(0)
    {
        std::vector<uint8_t> sector = read_vector("unscramble/11_invalid_mode_non_zeroed_intermediate_last_byte.uns.0.fail");
        scrambler.process(sector.data(), sector.data(), 0, sector.size());
        std::ofstream ofs("unscramble/11_invalid_mode_non_zeroed_intermediate_last_byte.0.fail", std::fstream::binary);
        ofs.write((char *)sector.data(), sector.size());
    }

    std::set<std::filesystem::path> test_files;
    for(auto const &f : std::filesystem::directory_iterator("unscramble"))
        if(f.is_regular_file())
            test_files.insert(f.path());

    for(auto const &f : test_files)
    {
        std::cout << std::format("descramble: {}... ", f.filename().string()) << std::flush;

        std::vector<uint8_t> sector = read_vector(f);

        auto tokens = tokenize(f.filename().string(), ".", nullptr);
        if(tokens.size() == 3)
        {
            int32_t lba = 0;
            int32_t *lba_ptr = &lba;
            if(tokens[1] == "null")
                lba_ptr = nullptr;
            else
                *lba_ptr = str_to_int(tokens[1]);
            bool scrambled = tokens[2] == "pass";
            bool unscrambled = scrambler.descramble(sector.data(), lba_ptr, sector.size());

            if(unscrambled == scrambled)
                std::cout << "success";
            else
            {
                std::cout << "failure";
                success = false;
            }
        }

        std::cout << std::endl;
    }

    return success;
}

bool test_crc()
{
    bool success = true;

    std::string check_value("123456789");

    // CRC-16/GSM
    auto crc16 = CRC16_GSM().update((uint8_t *)check_value.data(), check_value.length()).final();
    auto crc16_match = crc16 == 0xCE3C;
    std::cout << std::format("CRC-16/GSM: 0x{:04X}, {}", crc16, crc16_match ? "success" : "failure") << std::endl;
    if(!crc16_match)
        success = false;

    // CRC-32
    auto crc32 = CRC32().update((uint8_t *)check_value.data(), check_value.length()).final();
    auto crc32_match = crc32 == 0xCBF43926;
    std::cout << std::format("CRC-32: 0x{:08X}, {}", crc32, crc32_match ? "success" : "failure") << std::endl;
    if(!crc32_match)
        success = false;

    // EDC
    auto edc = EDC().update((uint8_t *)check_value.data(), check_value.length()).final();
    auto edc_match = edc == 0x6EC2EDC4;
    std::cout << std::format("EDC: 0x{:08X}, {}", edc, edc_match ? "success" : "failure") << std::endl;
    if(!edc_match)
        success = false;

    // CRC reciprocal
    bool reciprocal_match = CRC<uint32_t, 0x04C11DB7, 0x12345678, 0x87654321, true, false, false>().update((uint8_t *)check_value.data(), check_value.length()).final()
                         == CRC<uint32_t, 0x04C11DB7, 0x12345678, 0x87654321, true, false, true>().update((uint8_t *)check_value.data(), check_value.length()).final();
    std::cout << std::format("CRC normal/reciprocal test: {}", reciprocal_match ? "success" : "failure") << std::endl;

    return success;
}

const std::array<std::array<uint8_t, CD_RW_PACK_CONTEXT_SECTORS * CD_SUBCODE_SIZE>, 4> RW_TEST_CASES = {
    {
     // All 0
        { 0 },
     // All 1 (except P parity)
        { 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f,
            0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
            0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d,
            0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a,
            0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
            0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
            0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f,
            0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f,
            0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
            0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b,
            0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f,
            0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
            0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
            0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f,
            0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f, 0x3f, 0x3f, 0x3f, 0x2a, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
            0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x0d, 0x1b, 0x3c, 0x3f },
     // Random (correct P parity)
        { 0x26, 0x30, 0x21, 0x16, 0x0c, 0x1c, 0x3d, 0x0d, 0x16, 0x3a, 0x1c, 0x39, 0x39, 0x02, 0x17, 0x28, 0x04, 0x0c, 0x36, 0x09, 0x1e, 0x3a, 0x32, 0x21, 0x2a, 0x0f, 0x33, 0x39, 0x2c, 0x13, 0x04,
            0x03, 0x1b, 0x27, 0x3f, 0x28, 0x31, 0x0d, 0x05, 0x0e, 0x33, 0x35, 0x19, 0x2d, 0x10, 0x3d, 0x25, 0x3b, 0x04, 0x31, 0x03, 0x00, 0x04, 0x34, 0x0b, 0x23, 0x16, 0x1d, 0x22, 0x18, 0x3e, 0x13,
            0x01, 0x38, 0x02, 0x0c, 0x08, 0x24, 0x0d, 0x27, 0x3a, 0x09, 0x3e, 0x19, 0x20, 0x22, 0x34, 0x04, 0x01, 0x13, 0x30, 0x06, 0x20, 0x3b, 0x19, 0x08, 0x3c, 0x29, 0x0b, 0x37, 0x26, 0x36, 0x37,
            0x21, 0x0a, 0x11, 0x1f, 0x11, 0x2d, 0x37, 0x25, 0x34, 0x08, 0x14, 0x07, 0x2e, 0x2d, 0x02, 0x32, 0x35, 0x35, 0x28, 0x18, 0x05, 0x05, 0x0f, 0x15, 0x01, 0x1a, 0x09, 0x16, 0x32, 0x0a, 0x05,
            0x03, 0x07, 0x1c, 0x15, 0x17, 0x11, 0x35, 0x38, 0x2b, 0x3b, 0x39, 0x00, 0x31, 0x38, 0x08, 0x20, 0x16, 0x29, 0x36, 0x0c, 0x3d, 0x37, 0x33, 0x1d, 0x32, 0x19, 0x20, 0x0a, 0x09, 0x2a, 0x33,
            0x1f, 0x0f, 0x05, 0x27, 0x3b, 0x08, 0x11, 0x06, 0x20, 0x16, 0x08, 0x1c, 0x28, 0x0b, 0x33, 0x08, 0x05, 0x14, 0x11, 0x13, 0x28, 0x3f, 0x2e, 0x07, 0x28, 0x0f, 0x0d, 0x1d, 0x37, 0x2f, 0x3c,
            0x05, 0x0c, 0x11, 0x06, 0x3b, 0x3c, 0x2a, 0x1d, 0x02, 0x2a, 0x0e, 0x38, 0x14, 0x0d, 0x30, 0x3f, 0x16, 0x1f, 0x25, 0x3b, 0x2b, 0x15, 0x33, 0x17, 0x2e, 0x29, 0x2f, 0x07, 0x26, 0x39, 0x31,
            0x3a, 0x0c, 0x02, 0x20, 0x30, 0x24, 0x1d, 0x33, 0x29, 0x3e, 0x0e, 0x27, 0x02, 0x2f, 0x37, 0x33, 0x2e, 0x2f, 0x04, 0x17, 0x32, 0x29, 0x22, 0x13, 0x01, 0x25, 0x14, 0x28, 0x39, 0x1c, 0x3e,
            0x05, 0x34, 0x2e, 0x04, 0x0f, 0x09, 0x2a, 0x00, 0x38, 0x15, 0x0f, 0x32, 0x15, 0x1a, 0x14, 0x38, 0x34, 0x11, 0x33, 0x00, 0x3b, 0x3a, 0x24, 0x04, 0x1b, 0x17, 0x21, 0x37, 0x1b, 0x15, 0x1a,
            0x12, 0x34, 0x18, 0x1d, 0x03, 0x0a, 0x21, 0x35, 0x0c, 0x29, 0x03, 0x19, 0x14, 0x13, 0x28, 0x25, 0x06, 0x00, 0x3f, 0x23, 0x27, 0x22, 0x19, 0x15, 0x38, 0x0a, 0x09, 0x22, 0x25, 0x37, 0x29,
            0x32, 0x25, 0x19, 0x1a, 0x2e, 0x10, 0x02, 0x24, 0x3a, 0x06, 0x02, 0x18, 0x01, 0x15, 0x36, 0x1f, 0x20, 0x3f, 0x26, 0x02, 0x02, 0x09, 0x2f, 0x3f, 0x18, 0x28, 0x11, 0x2c, 0x30, 0x28, 0x1a,
            0x3f, 0x0f, 0x3b, 0x08, 0x25, 0x3a, 0x11, 0x15, 0x3d, 0x1f, 0x3b, 0x0d, 0x03, 0x2d, 0x35, 0x27, 0x39, 0x05, 0x21, 0x1b, 0x17, 0x2a, 0x15, 0x3f, 0x09, 0x02, 0x08, 0x35, 0x38, 0x30, 0x2e,
            0x32, 0x04, 0x2a, 0x3d, 0x2a, 0x12, 0x02, 0x0f, 0x01, 0x35, 0x3e, 0x06, 0x33, 0x3e, 0x1b, 0x1e, 0x1d, 0x0a, 0x01, 0x0f, 0x37, 0x19, 0x27, 0x16, 0x10, 0x1b, 0x16, 0x31, 0x1b, 0x30, 0x1e,
            0x35, 0x09, 0x0a, 0x0a, 0x00, 0x21, 0x13, 0x34, 0x1f, 0x10, 0x30, 0x23, 0x08, 0x34, 0x02, 0x39, 0x0d, 0x03, 0x00, 0x2f, 0x24, 0x1b, 0x1b, 0x16, 0x33, 0x0c, 0x33, 0x31, 0x05, 0x20, 0x0a,
            0x35, 0x13, 0x0e, 0x22, 0x08, 0x35, 0x20, 0x0b, 0x00, 0x33, 0x14, 0x22, 0x2a, 0x3f, 0x2c, 0x1a, 0x07, 0x28, 0x35, 0x35, 0x1c, 0x2f, 0x05, 0x07, 0x04, 0x36, 0x32, 0x2d, 0x0a, 0x1f, 0x15,
            0x19, 0x08, 0x02, 0x21, 0x15, 0x14, 0x20, 0x2d, 0x1a, 0x11, 0x1d, 0x3e, 0x36, 0x3e, 0x36 },
     // Real data
        { 0x09, 0x00, 0x00, 0x16, 0x04, 0x35, 0x05, 0x14, 0x3F, 0x38, 0x40, 0x00, 0x00, 0x43, 0x5E, 0x40, 0x00, 0x08, 0x06, 0x5C, 0x2B, 0x09, 0x5D, 0x7A, 0x09, 0x7E, 0x40, 0x4D, 0x04, 0x35, 0x05,
            0x15, 0x00, 0x7F, 0x0C, 0x00, 0x40, 0x00, 0x01, 0x03, 0x7C, 0x38, 0x46, 0x47, 0x30, 0x3E, 0x40, 0x7A, 0x09, 0x01, 0x04, 0x07, 0x04, 0x35, 0x05, 0x56, 0x3E, 0x00, 0x3F, 0x44, 0x00, 0x00,
            0x38, 0x00, 0x00, 0x07, 0x06, 0x3F, 0x0A, 0x3A, 0x3C, 0x7A, 0x09, 0x00, 0x08, 0x30, 0x04, 0x35, 0x05, 0x17, 0x01, 0x3E, 0x00, 0x7F, 0x00, 0x40, 0x00, 0x0C, 0x00, 0x40, 0x26, 0x47, 0x05,
            0x69, 0x09, 0x3A, 0x09, 0x30, 0x04, 0x12, 0x08, 0x35, 0x05, 0x18, 0x1F, 0x01, 0x78, 0x00, 0x3F, 0x40, 0x40, 0x40, 0x03, 0x00, 0x06, 0x78, 0x1B, 0x22, 0x7C, 0x7A, 0x09, 0x40, 0x48, 0x53,
            0x00, 0x35, 0x05, 0x59, 0x20, 0x3F, 0x47, 0x73, 0x40, 0x7F, 0x40, 0x40, 0x1C, 0x40, 0x26, 0x20, 0x10, 0x4A, 0x73, 0x3A, 0x09, 0x0D, 0x04, 0x3C, 0x08, 0x16, 0x05, 0x5A, 0x3C, 0x00, 0x03,
            0x4C, 0x3F, 0x00, 0x3C, 0x00, 0x00, 0x07, 0x06, 0x1E, 0x3B, 0x18, 0x36, 0x7A, 0x09, 0x20, 0x08, 0x29, 0x00, 0x35, 0x05, 0x1B, 0x00, 0x07, 0x3C, 0x78, 0x00, 0x7F, 0x03, 0x38, 0x18, 0x40,
            0x26, 0x40, 0x3C, 0x64, 0x0B, 0x7A, 0x09, 0x06, 0x00, 0x25, 0x08, 0x16, 0x05, 0x1B, 0x00, 0x20, 0x40, 0x07, 0x3F, 0x40, 0x40, 0x46, 0x06, 0x0C, 0x06, 0x78, 0x0B, 0x03, 0x72, 0x79, 0x09,
            0x41, 0x40, 0x78, 0x00, 0x35, 0x45, 0x1C, 0x43, 0x00, 0x78, 0x20, 0x00, 0x7F, 0x3F, 0x40, 0x00, 0x43, 0x46, 0x78, 0x18, 0x6B, 0x08, 0x3A, 0x09, 0x00, 0x00, 0x03, 0x04, 0x16, 0x05, 0x5C,
            0x1C, 0x00, 0x00, 0x4C, 0x30, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 0x1B, 0x15, 0x79, 0x09, 0x20, 0x03, 0x3F, 0x04, 0x35, 0x05, 0x1D, 0x3F, 0x07, 0x00, 0x40, 0x06, 0x5C, 0x20,
            0x0F, 0x03, 0x40, 0x06, 0x60, 0x07, 0x51, 0x53, 0x3A, 0x09, 0x03, 0x04, 0x2B, 0x04, 0x35, 0x05, 0x1D, 0x31, 0x3F, 0x41, 0x00, 0x00, 0x43, 0x47, 0x70, 0x03, 0x03, 0x26, 0x40, 0x14, 0x21,
            0x5E, 0x79, 0x09, 0x43, 0x41, 0x56, 0x04, 0x35, 0x45, 0x5E, 0x00, 0x7F, 0x1F, 0x40, 0x40, 0x00, 0x61, 0x40, 0x78, 0x03, 0x06, 0x38, 0x37, 0x77, 0x6A, 0x7A, 0x09, 0x38, 0x02, 0x01, 0x00,
            0x35, 0x05, 0x5F, 0x00, 0x00, 0x1F, 0x4F, 0x00, 0x00, 0x38, 0x30, 0x00, 0x38, 0x26, 0x00, 0x3B, 0x10, 0x2D, 0x7A, 0x09, 0x00, 0x04, 0x39, 0x00, 0x16, 0x05, 0x20, 0x1F, 0x00, 0x00, 0x4F,
            0x0F, 0x40, 0x00, 0x0C, 0x00, 0x40, 0x26, 0x40, 0x02, 0x60, 0x6C, 0x7A, 0x09, 0x00, 0x04, 0x1A, 0x00, 0x35, 0x05, 0x21, 0x30, 0x03, 0x40, 0x00, 0x0F, 0x47, 0x40, 0x40, 0x00, 0x00, 0x06,
            0x7C, 0x00, 0x0F, 0x6F, 0x7A, 0x09, 0x40, 0x41, 0x62, 0x00, 0x56, 0x05, 0x21, 0x41, 0x00, 0x03, 0x00, 0x20, 0x07, 0x03, 0x40, 0x00, 0x00, 0x46, 0x40, 0x05, 0x02, 0x31, 0x79, 0x09, 0x00,
            0x04, 0x39, 0x03, 0x16, 0x05, 0x62, 0x0F, 0x00, 0x00, 0x41, 0x00, 0x20, 0x03, 0x03, 0x00, 0x00, 0x06, 0x00, 0x09, 0x13, 0x0B, 0x7A, 0x09, 0x00, 0x08, 0x09, 0x03, 0x35, 0x05, 0x22, 0x1F,
            0x07, 0x00, 0x40, 0x00, 0x40, 0x30, 0x03, 0x00, 0x40, 0x26, 0x40, 0x56, 0x19, 0x23, 0x39 },
     }
};

bool test_rw_pack()
{
    bool success = true;
    const auto TEST_SIZE = CD_RW_PACK_CONTEXT_SECTORS * CD_SUBCODE_SIZE;
    const unsigned int CENTER_SECTOR = 2;
    std::array<uint8_t, TEST_SIZE> bytes = {};

    for(unsigned int test_case_i = 0; test_case_i < RW_TEST_CASES.size(); ++test_case_i)
    {
        auto no_errors_valid = valid_rw_packs(RW_TEST_CASES[test_case_i]);
        if(!no_errors_valid)
            success = false;
        std::cout << std::format("R-W {}: validate: {}", test_case_i, no_errors_valid ? "success" : "failure") << std::endl;

        auto one_error_located = true;
        for(unsigned int i = 0; i < TEST_SIZE; ++i)
        {
            bytes = RW_TEST_CASES[test_case_i];
            bytes[i] ^= 0x03;
            unsigned int error_sector = i / CD_SUBCODE_SIZE;
            auto expected_valid = error_sector != CENTER_SECTOR;
            auto test_valid = valid_rw_packs(bytes);

            if(expected_valid != test_valid)
            {
                one_error_located = false;
            }
        }
        if(!one_error_located)
            success = false;
        std::cout << std::format("R-W {}: 1 error located: {}", test_case_i, one_error_located ? "success" : "failure") << std::endl;

        // Note: This takes a while to run, it could probably be trimmed
        // to focus on only a few packs.
        auto two_errors_located = true;
        for(unsigned int i = 0; i < TEST_SIZE; ++i)
        {
            for(unsigned int j = 0; j < TEST_SIZE; ++j)
            {
                bytes = RW_TEST_CASES[test_case_i];
                bytes[i] ^= 0x05;
                bytes[j] ^= 0x35;
                unsigned int error_sector_i = i / CD_SUBCODE_SIZE;
                unsigned int error_sector_j = j / CD_SUBCODE_SIZE;
                auto expected_valid = (error_sector_i != CENTER_SECTOR) && (error_sector_j != CENTER_SECTOR);
                auto test_valid = valid_rw_packs(bytes);

                if(expected_valid != test_valid)
                {
                    two_errors_located = false;
                }
            }
        }
        if(!two_errors_located)
            success = false;
        std::cout << std::format("R-W {}: 2 errors located: {}", test_case_i, two_errors_located ? "success" : "failure") << std::endl;

        auto burst_error_located = true;
        const unsigned int MAX_BURST_SIZE = 16;
        for(unsigned int i = 0; i < TEST_SIZE + MAX_BURST_SIZE; ++i)
        {
            unsigned int burst_start = i < MAX_BURST_SIZE - 1 ? 0 : i - (MAX_BURST_SIZE - 1);
            unsigned int burst_end = i < TEST_SIZE - 1 ? i : (TEST_SIZE - 1);
            bytes = RW_TEST_CASES[test_case_i];
            for(unsigned int j = burst_start; j <= burst_end; ++j)
            {
                bytes[j] ^= 0x05;
            }
            unsigned int error_sector_start = burst_start / CD_SUBCODE_SIZE;
            unsigned int error_sector_end = burst_end / CD_SUBCODE_SIZE;
            auto expected_valid = (error_sector_start != CENTER_SECTOR) && (error_sector_end != CENTER_SECTOR);
            auto test_valid = valid_rw_packs(bytes);

            if(expected_valid != test_valid)
            {
                burst_error_located = false;
            }
        }
        if(!burst_error_located)
            success = false;
        std::cout << std::format("R-W {}: burst error located: {}", test_case_i, burst_error_located ? "success" : "failure") << std::endl;

        // Note: Not as exhaustive as the earlier tests. More than two errors
        // will not always be detectable, but the following pattern is
        // successfully detected with the test cases.
        auto more_than_two_fails = true;
        const unsigned int MAX_ERRORS = 7;
        const unsigned int LOCATABLE_ERRORS = 4 / 2; // Design distance of the (24,20) code
        const unsigned int PACK_START_OFFSET = CENTER_SECTOR * CD_SUBCODE_SIZE - MAX_ERRORS * 24;

        // Run through patterns of errors in the first MAX_ERRORS bytes.
        for(unsigned int i = 0; i < (1 << MAX_ERRORS) - 1; ++i)
        {
            bytes = RW_TEST_CASES[test_case_i];
            unsigned int error_count = 0;
            for(unsigned int j = 0; j < MAX_ERRORS; ++j)
            {
                if(i & (1 << j))
                {
                    // Calculate the interleaved location
                    unsigned int offset = PACK_START_OFFSET + (j & 7) * 24 + j;
                    bytes[offset] ^= 0x3;
                    error_count += 1;
                }
            }

            // The errors are always located outside of the center sector,
            // but they're part of a pack that extends into the center sector.
            // If there are too many errors it should be detected but not
            // located, so the center sector is marked invalid anyway.
            auto expected_valid = error_count <= LOCATABLE_ERRORS;
            auto test_valid = valid_rw_packs(bytes);
            if(expected_valid != test_valid)
            {
                more_than_two_fails = false;
            }
        }
        if(!more_than_two_fails)
            success = false;
        std::cout << std::format("R-W {}: 3-7 errors detected but not located: {}", test_case_i, more_than_two_fails ? "success" : "failure") << std::endl;
    }

    return success;
}



int main(int argc, char *argv[])
{
    int success = 0;

    success |= (int)!test_scale();
    std::cout << std::endl;
    success |= (int)!test_bcd();
    std::cout << std::endl;
    success |= (int)!test_lbamsf();
    std::cout << std::endl;
    success |= (int)!test_unscramble();
    std::cout << std::endl;
    success |= (int)!test_crc();
    std::cout << std::endl;
    success |= (int)!test_rw_pack();
    std::cout << std::endl;

    return success;
}
